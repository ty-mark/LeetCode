/*
Given n, how many structurally unique BST's (binary search trees) that store values 1 ... n?

Example:

	Input: 3
	Output: 5
	Explanation:
	Given n = 3, there are a total of 5 unique BST's:

	   1         3     3      2      1
	    \       /     /      / \      \
	     3     2     1      1   3      2
	    /     /       \                 \
	   2     1         2                 3
*/


/* F(n) = F(0) * F(n - 1) + F(1) * F(n - 2) + ... + F(n - 1) * F(0)

	Base case:
		n = 0 => null node 					=> dp[0] = 1

		n = 1 =>	1	   					=> dp[1] = 1		
				   / \
				null null	

		n = 2 => 	1			2			=> dp[2] = dp[0] * dp[1] + dp[1] * dp[0] = 2
				   / \		   / \	
				 null 2		  1  null

	Note:
		1) Total number of nodes => n
		2) Each one (t) could be the root node, then BST requires (1,...,t-1)    => left subtree 
															  and (t + 1,...,n)  => right subtree
		3) For this case, G(t) = G(t - 1) * G(n - t)
		4) The number of combinations G(t) does not depend on the individual numbers, but how many numbers are in the set
		For example, dp[5] could represent the different combinations of either {1,2,3,4,5} or {7,8,9,10,11}
*/
class Solution {
    public int numTrees(int n) {
        int[] dp = new int[n + 1];
        dp[0] = dp[1] = 1;
        for (int i = 2; i <= n; i++) {
        	for (int j = 1; j <= i; j++) {
        		dp[i] += dp[j - 1] * dp[i - j];
        	}
        }
        return dp[n];
    }
}




/*
Given an integer n, generate all structurally unique BST's (binary search trees) that store values 1 ... n.

Example:

	Input: 3
	Output:
	[
	  [1,null,3,2],
	  [3,2,null,1],
	  [3,1,null,null,2],
	  [2,1,3],
	  [1,null,2,null,3]
	]
	Explanation:
	The above output corresponds to the 5 unique BST's shown below:

	   1         3     3      2      1
	    \       /     /      / \      \
	     3     2     1      1   3      2
	    /     /       \                 \
	   2     1         2                 3
*/

/* DP + Divide-and-Conquer */
class Solution {
    public List<TreeNode> generateTrees(int n) {
        List<TreeNode>[] dp = new List[n + 1]; // an array of list references
        if (n == 0) return new ArrayList<TreeNode>();;
        dp[0] = new ArrayList(); dp[0].add(null); // when the subtree is empty, add NULL value
        // construct the dp array
        for (int i = 1; i <= n; i++) {
            dp[i] = new ArrayList();
            // i --> total number of nodes
            // j --> number of nodes in the left subtree
            for (int j = 0; j < i; j++) {
                for (TreeNode nodeL : dp[j]) {
                    for (TreeNode nodeR : dp[i - j - 1]) {
                        // current root: j+1
                        TreeNode root = new TreeNode(j + 1);
                        // left subtree has been stored in the dp array
                        root.left = nodeL;
                        // right subtree can be generated by shifting the existing results (with same number of nodes) to the right by a distance of (j+1)
                        root.right = clone(nodeR, j + 1);
                        dp[i].add(root);
                    }
                }
            }
        }
        return dp[n];
    }

    /* increase the value node by node to by amount of offset in preorder traversal */
    private TreeNode clone(TreeNode root, int offset) {
        if (root == null) return null;
        TreeNode newRoot = new TreeNode(root.val + offset);
        newRoot.left = clone(root.left, offset);
        newRoot.right = clone(root.right, offset);
        return newRoot;
    }
}

/* Divide-and-Conquer
	
	1,2,3,...,n => 
		|1|2,3,...,n && 1|2|3,4,...,n && 1,2|3|4,5,...,n && ... && 1,2,3,...,n-1|n|

	Note: if n == 0 it should return an empty list, rather than a list with null node, thus we need a separate check for that
 */
class Solution {
    public List<TreeNode> generateTrees(int n) {
    	return (n == 0) ? new ArrayList<TreeNode>() : generateTrees(1, n);
    }
    private List<TreeNode> generateTrees(int start, int end) {
    	List<TreeNode> res = new ArrayList();
    	if (start > end) {
    		res.add(null);
    	} else {
    		for (int i = start; i <= end; i++) {
    			List<TreeNode> left = generateTrees(start, i - 1);
    			List<TreeNode> right = generateTrees(i + 1, end);
    			for (TreeNode l : left) {
    				for (TreeNode r : right) {
    					TreeNode root = new TreeNode(i);
    					root.left = l;
    					root.right = r;
    					res.add(root);
    				}
    			}
    		}
    	}
    	return res;
    }
}